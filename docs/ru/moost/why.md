# Почему Moost

::: warning
Работа над Moost продолжается. Moost готов к использованию, но некоторые API могут быть изменены.
:::

В процессе разработки крупных корпоративных приложений разработчики часто сталкиваются с огромной задачей управления обширным кодовой базой.
По мере роста кода он часто превращается в запутанный лабиринт зависимостей и сложностей, заслуживая печально известную метку "устаревший код".

Вот где Moost приходит на помощь - комплексное решение, разработанное для преодоления этих трудностей.
Moost оснащает разработчиков набором техник, которые позволяют упростить создание надежных приложений и ускорить процесс разработки, не боясь устаревания кода.

## Проблемы

Почему код превращается в устаревший и становится непосильной задачей по поддержке? Причин много:

- _Ошибка дизайна_: Приложение, созданное без должного учета связи компонентов, часто приводит к хрупкой системе, где изменение одной части может непреднамеренно повлиять на другие.
- _Перегрузка заплатками_: Даже хорошо спроектированное приложение может нести на себе бремя бесчисленных маленьких патчей, превращаясь в спагетти-код.
- _Сложные модели_: Приложения, выполняющие сложные задачи, часто развивают сложные модели, представляющие серьезные вызовы для разработчиков.

Независимо от причины, проблема возникает, когда код становится хрупким и компоненты становятся неразрывно связанными.
Какое есть решение? Применение проверенных принципов программной инженерии, таких как принципы [SOLID](https://ru.wikipedia.org/wiki/SOLID), для обеспечения долгосрочного здоровья и гибкости приложений.

Несколько решений, таких как `nestjs`, вдохновленный `angular`, предлагают встроенную поддержку общих шаблонов проектирования, таких как принципы SOLID, с использованием декораторов и метаданных.
Однако `nestjs`, будучи хорошим решением, имеет модульную систему, которую понять довольно непросто.

## Преимущества Moost

Moost, подобно `nestjs`, предоставляет встроенную поддержку общих шаблонов проектирования, включая принципы SOLID, обеспечивая создание понятных, гибких и удобных для поддержки приложений.
Однако Moost отличается следующим:

- _Устранение излишних абстракций модуля_: Moost избавляется от ненужных абстракций модуля, делая фреймворк более простым, интуитивно понятным и пользовательски-ориентированным.
- _Внедрение зависимостей_: Moost использует мощь [@prostojs/infact](https://github.com/prostojs/infact), надежного фреймворка внедрения зависимостей.
- _Интеграция метаданных через [@prostojs/mate](https://github.com/prostojs/mate)_: Moost интегрирует мощный слой метаданных, обеспечивая безпроблемное взаимодействие с метаданными.
- _Поддержка [DTOs](https://ru.wikipedia.org/wiki/Data_transfer_object) и валидации_: Moost включает поддержку DTO и валидации с использованием [@prostojs/valido](https://github.com/prostojs/valido).
- _Независимость от фреймворка_: Moost не прямо зависит от `express` или `fastify`, но может использоваться с этими фреймворками через адаптер.
- _Использование преимуществ **Wooks Composables**_: Основываясь на фундаменте [Wooks](https://wooks.moost.org), Moost использует мощные возможности, предоставляемые Wooks Composables.

В сущности, Moost предлагает прочное основание для создания крупных масштабируемых серверных приложений.
С использованием возможностей `TypeScript` и `@Metadata` он упрощает процесс обучения разработчиков и позволяет им быстро создавать надежные приложения.
Выбирая Moost вы имеете все шансы сохранить код в поддерживаемом виде.